[{"id":0,"href":"/documentation/Diagrams/Architecture-Diagram/","title":"Architecture Diagram","parent":"Diagrams","content":"The data relative to the number of people detected by Wi-Fi sniffing and object detection and the number of moliceiros detected by object detection is captured by the respective modules in the sensors and this data is sent to the broker through a MQTT connection. The broker saves the data in a database and also sends it to the Web service (Flask). The web server (Gunicorn) interacts with the Web service and communicates with the Reverse Proxy Server (Nginx) through a Unix socket. The Reverse Proxy Server manages the load balance of requests. The user visualizes the web application in his device, sending and receiving HTTPS requests and responses.\n "},{"id":1,"href":"/documentation/Diagrams/Deployment-Diagram/","title":"Deployment Diagram","parent":"Diagrams","content":"In this diagram it is possible to view the several components of the system and how they interact between them.\n "},{"id":2,"href":"/documentation/Diagrams/Domain-Diagram/","title":"Domain Diagram","parent":"Diagrams","content":"The domain model of the project represents the real-world conceptual classes of the system, their attributes and how they are associated.\n "},{"id":3,"href":"/documentation/Diagrams/Use-Cases-Diagrams/","title":"Use Cases Diagrams","parent":"Diagrams","content":"API     Web Application     "},{"id":4,"href":"/documentation/Modules/Server-Configuration/","title":"Server Configuration","parent":"Modules","content":"The following topics describe the server configuration following the work flow to do so:\n The WebAppDev repository was cloned to the virtual machine  Gunicorn     A service of gunicorn was created to run the web application using eventlet on the same address and port of socket instanced on the web application. The file is located in /etc/systemd/system/webapp.service  [Unit] Description=Gunicorn instance to serve PEI2021_NAP project After=network.target [Service] User=hugolardosa Group=www-data WorkingDirectory=path/WebAppDev Environment=\u0026quot;PATH=path/WebAppDev/avenv/bin\u0026quot; ExecStart=path/WebAppDev/avenv/bin/gunicorn --worker-class eventlet -w 1 --bind=\u0026quot;0.0.0.0:5000\u0026quot; app:app [Install] WantedBy=multi-user.target It\u0026rsquo;s important to mention the gunicorn run atributes (gunicorn \u0026ndash;worker-class eventlet -w 1 \u0026ndash;bind=\u0026ldquo;0.0.0.0:5000\u0026rdquo; app:app)\n \u0026ndash;worker-class eventlet -w 1 These attributes are used to run the web server using the asynchronous process for socket.io \u0026ndash;bind=\u0026ldquo;0.0.0.0:5000\u0026rdquo; Indicates gunicorn the address and port the app and socket is running, NEEDS TO BE THE SAME AS THE ONES IN THE PYTHON APP app:app Indicates gunicorn the name and attribute of the flask web application  We need to run the webapp service, so it will always be running using sudo systemctl start webapp\nNGINX    We then need to configure the NGINX reverse proxy server, we need to link the local gunicorn and redirect it to the dev.aveiro-open-lab.pt.\n The file is located in /etc/nginx/sites-available/webapp  We start the file by pointing the / in the server to the local web app (0:0:0:0:5000)\nserver{ server_name dev.aveiro-open-lab.pt; location / { include proxy_params; proxy_pass http://0.0.0.0:5000; } Then, we need to point the /socket.io on the server to the local socket 0.0.0.0:5000 one\n location /socket.io{ include proxy_params; proxy_http_version 1.1; proxy_buffering off; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026quot;Upgrade\u0026quot;; proxy_pass http://0.0.0.0:5000/socket.io; } The rest of the file was generated by certbot so we can have the webapp running on https\n listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/dev.aveiro-open-lab.pt/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/dev.aveiro-open-lab.pt/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server{ if ($host = dev.aveiro-open-lab.pt) { return 301 https://$host$request_uri; } # managed by Certbot listen 80; server_name dev.aveiro-open-lab.pt; return 404; # managed by Certbot } We need to run the nginx service, so it will always be running using sudo systemctl start nginx\n"},{"id":5,"href":"/documentation/Modules/WebApp/","title":"Web App","parent":"Modules","content":"Basic architecture of the web application    The web application is a flask app, running on the gunicorn server and uses NGINX has a proxy server.\nFile Structure     app.py - main app running on server /templates - folder containing all the Static rendered Jinja2 HTML files /templates/template.html - contains the base HTML page /templates/index.html - extends template and has the HTML code to homepage elements /templates/person.html - extends template and has the HTML code to show the detection data  Main functions    The two main functions of the app are home() and people():\n home() - renders the template of the index HTML webpage. people() - renders the template of the main page where the detection data is showed.  To render the HTML pages with jinja the functions return render_template(\u0026lsquo;person.html\u0026rsquo;, pagename=\u0026ldquo;Moliceiros and People detection\u0026rdquo;) the argument pagename renders the page name on the html files\nBroker access    In flask we access the broker and subscribe to topics to get real time data. On these lines of code we access the broker\napp.config[\u0026#39;MQTT_BROKER_URL\u0026#39;] = \u0026#39;###.nap.av.it.pt\u0026#39; app.config[\u0026#39;MQTT_BROKER_PORT\u0026#39;] = 1883 app.config[\u0026#39;MQTT_REFRESH_TIME\u0026#39;] = 1.0 mqtt = Mqtt(app) mqtt = Mqtt(app) starts the broker access for the Broker. handle_connect subscribes to the topic, and handle_mqtt_message, gets the message in real-time and sends it through a socket to the web app\n@mqtt.on_connect() def handle_connect(client, userdata, flags, rc): mqtt.subscribe(\u0026#39;sniffing\u0026#39;) @mqtt.on_message() def handle_mqtt_message(client, userdata, message): data = dict( topic=message.topic, payload=message.payload.decode() ) # emit a mqtt_message event to the socket containing the message data socketio.emit(\u0026#39;mqtt_message\u0026#39;, data=data) print(data) Socket IO    To show in real time the broker data from flask to HTML, we need to open a socket using socket.io, for that in the app.py file we: create a variable named socketio = SocketIO(app), and when receiving a message from the broker we send the data to the socket socketio.emit(\u0026lsquo;mqtt_message\u0026rsquo;, data=data)\nOn the html - template page:\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt; $(document).ready(function() { var socket = io(); socket.on(\u0026#39;connect\u0026#39;, function() { socket.emit(\u0026#39;my event\u0026#39;, {data: \u0026#39;I\\\u0026#39;m connected!\u0026#39;}); }); // listen for mqtt_message events  // when a new message is received, log and append the data to the page  socket.on(\u0026#39;mqtt_message\u0026#39;, (data) =\u0026gt; { console.log(data); $(\u0026#39;#sniffing_div\u0026#39;).html(data[\u0026#39;payload\u0026#39;]); //replace sniffing div  }) }); \u0026lt;/script\u0026gt; We connect to the socket and then send the data to the corresponded div\n"},{"id":6,"href":"/documentation/categories/","title":"Categories","parent":"Documentation","content":""},{"id":7,"href":"/documentation/diagrams/","title":"Diagrams","parent":"Documentation","content":""},{"id":8,"href":"/documentation/","title":"Documentation","parent":"","content":""},{"id":9,"href":"/documentation/modules/","title":"Modules","parent":"Documentation","content":""},{"id":10,"href":"/documentation/tags/","title":"Tags","parent":"Documentation","content":""}]